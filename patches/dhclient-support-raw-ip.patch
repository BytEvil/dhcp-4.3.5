From 127487a815eda1bee4f2188fe3d0621a15aa6849 Mon Sep 17 00:00:00 2001
From: BytEvil <itemcode@mail.ru>
Date: Sun, 23 Jul 2017 18:57:54 +0400
Subject: [PATCH] Add support for raw ip to dhclient

---
 common/bpf.c    | 26 ++++++++++++++++++++++++++
 common/lpf.c    | 44 ++++++++++++++++++++++++++++++++++++++++++++
 common/packet.c |  6 ++++++
 includes/dhcp.h |  1 +
 4 files changed, 77 insertions(+)

diff --git a/common/bpf.c b/common/bpf.c
index 1816496..0bf058f 100644
--- a/common/bpf.c
+++ b/common/bpf.c
@@ -203,6 +203,32 @@ struct bpf_insn *bpf_fddi_filter = NULL;
 #endif
 
 int dhcp_bpf_filter_len = sizeof dhcp_bpf_filter / sizeof (struct bpf_insn);
+
+struct bpf_insn dhcp_bpf_ip_filter [] = {
+	/* Make sure it's a UDP packet... */
+	BPF_STMT (BPF_LD + BPF_B + BPF_ABS, 9),
+	BPF_JUMP (BPF_JMP + BPF_JEQ + BPF_K, IPPROTO_UDP, 0, 6),
+       
+	/* Make sure this isn't a fragment... */
+	BPF_STMT(BPF_LD + BPF_H + BPF_ABS, 6),
+	BPF_JUMP(BPF_JMP + BPF_JSET + BPF_K, 0x1fff, 4, 0),
+
+	/* Get the IP header length... */
+	BPF_STMT (BPF_LDX + BPF_B + BPF_MSH, 0),
+
+	/* Make sure it's to the right port... */
+	BPF_STMT (BPF_LD + BPF_H + BPF_IND, 2),
+	BPF_JUMP (BPF_JMP + BPF_JEQ + BPF_K, 37, 0, 1),             /* patch */
+
+	/* If we passed all the tests, ask for the whole packet. */
+	BPF_STMT(BPF_RET+BPF_K, (u_int)-1),
+
+	/* Otherwise, drop it. */
+	BPF_STMT(BPF_RET+BPF_K, 0),
+};
+
+int dhcp_bpf_ip_filter_len = sizeof dhcp_bpf_ip_filter / sizeof (struct bpf_insn);
+
 #if defined (HAVE_TR_SUPPORT)
 struct bpf_insn dhcp_bpf_tr_filter [] = {
         /* accept all token ring packets due to variable length header */
diff --git a/common/lpf.c b/common/lpf.c
index ee3820b..e87b753 100644
--- a/common/lpf.c
+++ b/common/lpf.c
@@ -179,6 +179,9 @@ void if_deregister_send (info)
 extern struct sock_filter dhcp_bpf_filter [];
 extern int dhcp_bpf_filter_len;
 
+extern struct sock_filter dhcp_bpf_ip_filter [];
+extern int dhcp_bpf_ip_filter_len;
+
 #if defined (HAVE_TR_SUPPORT)
 extern struct sock_filter dhcp_bpf_tr_filter [];
 extern int dhcp_bpf_tr_filter_len;
@@ -186,6 +189,7 @@ static void lpf_tr_filter_setup (struct interface_info *);
 #endif
 
 static void lpf_gen_filter_setup (struct interface_info *);
+static void lpf_pureip_filter_setup (struct interface_info *);
 
 void if_register_receive (info)
 	struct interface_info *info;
@@ -212,6 +216,9 @@ void if_register_receive (info)
 		lpf_tr_filter_setup (info);
 	else
 #endif
+	if (info -> hw_address.hbuf [0] == HTYPE_PUREIP)
+		lpf_pureip_filter_setup (info);
+	else
 		lpf_gen_filter_setup (info);
 
 	if (!quiet_interface_discovery)
@@ -276,6 +283,39 @@ static void lpf_gen_filter_setup (info)
 	}
 }
 
+static void lpf_pureip_filter_setup (info)
+		struct interface_info *info;
+{
+		struct sock_fprog p;
+
+		memset(&p, 0, sizeof(p));
+
+	/* Set up the bpf filter program structure.    This is defined in
+	   bpf.c */
+	p.len = dhcp_bpf_ip_filter_len;
+	p.filter = dhcp_bpf_ip_filter;
+
+		/* Patch the server port into the LPF  program...
+	   XXX changes to filter program may require changes
+	   to the insn number(s) used below! XXX */
+	dhcp_bpf_ip_filter [6].k = ntohs ((short)local_port);
+
+	if (setsockopt (info -> rfdesc, SOL_SOCKET, SO_ATTACH_FILTER, &p,
+			sizeof p) < 0) {
+		if (errno == ENOPROTOOPT || errno == EPROTONOSUPPORT ||
+			errno == ESOCKTNOSUPPORT || errno == EPFNOSUPPORT ||
+			errno == EAFNOSUPPORT) {
+			log_error ("socket: %m - make sure");
+			log_error ("CONFIG_PACKET (Packet socket) %s",
+				   "and CONFIG_FILTER");
+			log_error ("(Socket Filtering) are enabled %s",
+				   "in your kernel");
+			log_fatal ("configuration!");
+		}
+		log_fatal ("Can't install packet filter program: %m");
+	}
+}
+
 #if defined (HAVE_TR_SUPPORT)
 static void lpf_tr_filter_setup (info)
 	struct interface_info *info;
@@ -548,6 +588,10 @@ get_hw_addr(const char *name, struct hardware *hw) {
 			hw->hbuf[0] = HTYPE_FDDI;
 			memcpy(&hw->hbuf[1], sa->sa_data, 6);
 			break;
+		case ARPHRD_NONE:
+			hw->hlen = 1;
+			hw->hbuf[0] = HTYPE_PUREIP;
+			break;
 		default:
 			log_fatal("Unsupported device type %ld for \"%s\"",
 				  (long int)sa->sa_family, name);
diff --git a/common/packet.c b/common/packet.c
index e600e37..464c10d 100644
--- a/common/packet.c
+++ b/common/packet.c
@@ -120,6 +120,9 @@ void assemble_hw_header (interface, buf, bufix, to)
 	case HTYPE_INFINIBAND:
 		log_error("Attempt to assemble hw header for infiniband");
 		break;
+	case HTYPE_PUREIP:
+		log_error("Attempt to assemble hw header for pure IP");
+		break;
 	case HTYPE_ETHER:
 	default:
 		assemble_ethernet_header(interface, buf, bufix, to);
@@ -214,6 +217,9 @@ ssize_t decode_hw_header (interface, buf, bufix, from)
 	case HTYPE_INFINIBAND:
 		log_error("Attempt to decode hw header for infiniband");
 		return (0);
+	case HTYPE_PUREIP:
+		log_error("Attempt to decode hw header for pure IP");
+		return (0);
 	case HTYPE_ETHER:
 	default:
 		return (decode_ethernet_header(interface, buf, bufix, from));
diff --git a/includes/dhcp.h b/includes/dhcp.h
index f916468..28818de 100644
--- a/includes/dhcp.h
+++ b/includes/dhcp.h
@@ -77,6 +77,7 @@ struct dhcp_packet {
 #define HTYPE_IEEE802	6               /* IEEE 802.2 Token Ring...	*/
 #define HTYPE_FDDI	8		/* FDDI...			*/
 #define HTYPE_INFINIBAND  32		/* IP over Infiniband		*/
+#define HTYPE_PUREIP  35		/* Pure IP		*/
 #define HTYPE_IPMP       255            /* IPMP - random hw address - there
 					 * is no standard for this so we
 					 * just steal a type            */
-- 
2.13.2

